// -*- C++ -*-
//
// This file was generated by CLI, a command line interface
// compiler for C++.
//

#ifndef CLI_OPTIONS_HXX
#define CLI_OPTIONS_HXX

// Begin prologue.
//
//
// End prologue.

#include <list>
#include <deque>
#include <iosfwd>
#include <string>
#include <cstddef>
#include <exception>

#ifndef CLI_POTENTIALLY_UNUSED
#  if defined(_MSC_VER) || defined(__xlC__)
#    define CLI_POTENTIALLY_UNUSED(x) (void*)&x
#  else
#    define CLI_POTENTIALLY_UNUSED(x) (void)x
#  endif
#endif

namespace cli
{
  class usage_para
  {
    public:
    enum value
    {
      none,
      text,
      option
    };

    usage_para (value);

    operator value () const 
    {
      return v_;
    }

    private:
    value v_;
  };

  class unknown_mode
  {
    public:
    enum value
    {
      skip,
      stop,
      fail
    };

    unknown_mode (value);

    operator value () const 
    {
      return v_;
    }

    private:
    value v_;
  };

  // Exceptions.
  //

  class exception: public std::exception
  {
    public:
    virtual void
    print (::std::ostream&) const = 0;
  };

  ::std::ostream&
  operator<< (::std::ostream&, const exception&);

  class unknown_option: public exception
  {
    public:
    virtual
    ~unknown_option () throw ();

    unknown_option (const std::string& option);

    const std::string&
    option () const;

    virtual void
    print (::std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string option_;
  };

  class unknown_argument: public exception
  {
    public:
    virtual
    ~unknown_argument () throw ();

    unknown_argument (const std::string& argument);

    const std::string&
    argument () const;

    virtual void
    print (::std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string argument_;
  };

  class missing_value: public exception
  {
    public:
    virtual
    ~missing_value () throw ();

    missing_value (const std::string& option);

    const std::string&
    option () const;

    virtual void
    print (::std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string option_;
  };

  class invalid_value: public exception
  {
    public:
    virtual
    ~invalid_value () throw ();

    invalid_value (const std::string& option,
                   const std::string& value,
                   const std::string& message = std::string ());

    const std::string&
    option () const;

    const std::string&
    value () const;

    const std::string&
    message () const;

    virtual void
    print (::std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string option_;
    std::string value_;
    std::string message_;
  };

  class eos_reached: public exception
  {
    public:
    virtual void
    print (::std::ostream&) const;

    virtual const char*
    what () const throw ();
  };

  class file_io_failure: public exception
  {
    public:
    virtual
    ~file_io_failure () throw ();

    file_io_failure (const std::string& file);

    const std::string&
    file () const;

    virtual void
    print (::std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string file_;
  };

  class unmatched_quote: public exception
  {
    public:
    virtual
    ~unmatched_quote () throw ();

    unmatched_quote (const std::string& argument);

    const std::string&
    argument () const;

    virtual void
    print (::std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string argument_;
  };

  // Command line argument scanner interface.
  //
  // The values returned by next() are guaranteed to be valid
  // for the two previous arguments up until a call to a third
  // peek() or next().
  //
  // The position() function returns a monotonically-increasing
  // number which, if stored, can later be used to determine the
  // relative position of the argument returned by the following
  // call to next(). Note that if multiple scanners are used to
  // extract arguments from multiple sources, then the end
  // position of the previous scanner should be used as the
  // start position of the next.
  //
  class scanner
  {
    public:
    virtual
    ~scanner ();

    virtual bool
    more () = 0;

    virtual const char*
    peek () = 0;

    virtual const char*
    next () = 0;

    virtual void
    skip () = 0;

    virtual std::size_t
    position () = 0;
  };

  class argv_scanner: public scanner
  {
    public:
    argv_scanner (int& argc,
                  char** argv,
                  bool erase = false,
                  std::size_t start_position = 0);

    argv_scanner (int start,
                  int& argc,
                  char** argv,
                  bool erase = false,
                  std::size_t start_position = 0);

    int
    end () const;

    virtual bool
    more ();

    virtual const char*
    peek ();

    virtual const char*
    next ();

    virtual void
    skip ();

    virtual std::size_t
    position ();

    protected:
    std::size_t start_position_;
    int i_;
    int& argc_;
    char** argv_;
    bool erase_;
  };

  class argv_file_scanner: public argv_scanner
  {
    public:
    argv_file_scanner (int& argc,
                       char** argv,
                       const std::string& option,
                       bool erase = false,
                       std::size_t start_position = 0);

    argv_file_scanner (int start,
                       int& argc,
                       char** argv,
                       const std::string& option,
                       bool erase = false,
                       std::size_t start_position = 0);

    argv_file_scanner (const std::string& file,
                       const std::string& option,
                       std::size_t start_position = 0);

    struct option_info
    {
      // If search_func is not NULL, it is called, with the arg
      // value as the second argument, to locate the options file.
      // If it returns an empty string, then the file is ignored.
      //
      const char* option;
      std::string (*search_func) (const char*, void* arg);
      void* arg;
    };

    argv_file_scanner (int& argc,
                        char** argv,
                        const option_info* options,
                        std::size_t options_count,
                        bool erase = false,
                        std::size_t start_position = 0);

    argv_file_scanner (int start,
                       int& argc,
                       char** argv,
                       const option_info* options,
                       std::size_t options_count,
                       bool erase = false,
                       std::size_t start_position = 0);

    argv_file_scanner (const std::string& file,
                       const option_info* options = 0,
                       std::size_t options_count = 0,
                       std::size_t start_position = 0);

    virtual bool
    more ();

    virtual const char*
    peek ();

    virtual const char*
    next ();

    virtual void
    skip ();

    virtual std::size_t
    position ();

    // Return the file path if the peeked at argument came from a file and
    // the empty string otherwise. The reference is guaranteed to be valid
    // till the end of the scanner lifetime.
    //
    const std::string&
    peek_file ();

    // Return the 1-based line number if the peeked at argument came from
    // a file and zero otherwise.
    //
    std::size_t
    peek_line ();

    private:
    const option_info*
    find (const char*) const;

    void
    load (const std::string& file);

    typedef argv_scanner base;

    const std::string option_;
    option_info option_info_;
    const option_info* options_;
    std::size_t options_count_;

    struct arg
    {
      std::string value;
      const std::string* file;
      std::size_t line;
    };

    std::deque<arg> args_;
    std::list<std::string> files_;

    // Circular buffer of two arguments.
    //
    std::string hold_[2];
    std::size_t i_;

    bool skip_;

    static int zero_argc_;
    static std::string empty_string_;
  };

  template <typename X>
  struct parser;
}

#include <map>

#include <string>

#include <vector>

#include <cstddef>

#include <cstdint>

#include "../../option-types.hxx"

class options
{
  public:
  options ();

  options (int& argc,
           char** argv,
           bool erase = false,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (int start,
           int& argc,
           char** argv,
           bool erase = false,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (int& argc,
           char** argv,
           int& end,
           bool erase = false,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (int start,
           int& argc,
           char** argv,
           int& end,
           bool erase = false,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (::cli::scanner&,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  // Option accessors and modifiers.
  //
  const std::uint64_t&
  build2_metadata () const;

  std::uint64_t&
  build2_metadata ();

  void
  build2_metadata (const std::uint64_t&);

  bool
  build2_metadata_specified () const;

  void
  build2_metadata_specified (bool);

  const bool&
  help () const;

  bool&
  help ();

  void
  help (const bool&);

  const bool&
  version () const;

  bool&
  version ();

  void
  version (const bool&);

  const std::vector<std::string>&
  include_path () const;

  std::vector<std::string>&
  include_path ();

  void
  include_path (const std::vector<std::string>&);

  bool
  include_path_specified () const;

  void
  include_path_specified (bool);

  const std::string&
  output_dir () const;

  std::string&
  output_dir ();

  void
  output_dir (const std::string&);

  bool
  output_dir_specified () const;

  void
  output_dir_specified (bool);

  const cxx_version&
  std () const;

  cxx_version&
  std ();

  void
  std (const cxx_version&);

  bool
  std_specified () const;

  void
  std_specified (bool);

  const bool&
  generate_modifier () const;

  bool&
  generate_modifier ();

  void
  generate_modifier (const bool&);

  const bool&
  generate_specifier () const;

  bool&
  generate_specifier ();

  void
  generate_specifier (const bool&);

  const bool&
  generate_parse () const;

  bool&
  generate_parse ();

  void
  generate_parse (const bool&);

  const bool&
  generate_merge () const;

  bool&
  generate_merge ();

  void
  generate_merge (const bool&);

  const bool&
  generate_description () const;

  bool&
  generate_description ();

  void
  generate_description (const bool&);

  const bool&
  generate_file_scanner () const;

  bool&
  generate_file_scanner ();

  void
  generate_file_scanner (const bool&);

  const bool&
  generate_vector_scanner () const;

  bool&
  generate_vector_scanner ();

  void
  generate_vector_scanner (const bool&);

  const bool&
  generate_group_scanner () const;

  bool&
  generate_group_scanner ();

  void
  generate_group_scanner (const bool&);

  const bool&
  suppress_inline () const;

  bool&
  suppress_inline ();

  void
  suppress_inline (const bool&);

  const bool&
  suppress_cli () const;

  bool&
  suppress_cli ();

  void
  suppress_cli (const bool&);

  const std::string&
  cli_namespace () const;

  std::string&
  cli_namespace ();

  void
  cli_namespace (const std::string&);

  bool
  cli_namespace_specified () const;

  void
  cli_namespace_specified (bool);

  const std::string&
  ostream_type () const;

  std::string&
  ostream_type ();

  void
  ostream_type (const std::string&);

  bool
  ostream_type_specified () const;

  void
  ostream_type_specified (bool);

  const std::string&
  export_symbol () const;

  std::string&
  export_symbol ();

  void
  export_symbol (const std::string&);

  bool
  export_symbol_specified () const;

  void
  export_symbol_specified (bool);

  const bool&
  generate_cxx () const;

  bool&
  generate_cxx ();

  void
  generate_cxx (const bool&);

  const bool&
  generate_man () const;

  bool&
  generate_man ();

  void
  generate_man (const bool&);

  const bool&
  generate_html () const;

  bool&
  generate_html ();

  void
  generate_html (const bool&);

  const bool&
  generate_txt () const;

  bool&
  generate_txt ();

  void
  generate_txt (const bool&);

  const bool&
  generate_dep () const;

  bool&
  generate_dep ();

  void
  generate_dep (const bool&);

  const bool&
  stdout_ () const;

  bool&
  stdout_ ();

  void
  stdout_ (const bool&);

  const bool&
  suppress_undocumented () const;

  bool&
  suppress_undocumented ();

  void
  suppress_undocumented (const bool&);

  const bool&
  suppress_usage () const;

  bool&
  suppress_usage ();

  void
  suppress_usage (const bool&);

  const bool&
  long_usage () const;

  bool&
  long_usage ();

  void
  long_usage (const bool&);

  const bool&
  short_usage () const;

  bool&
  short_usage ();

  void
  short_usage (const bool&);

  const std::string&
  page_usage () const;

  std::string&
  page_usage ();

  void
  page_usage (const std::string&);

  bool
  page_usage_specified () const;

  void
  page_usage_specified (bool);

  const std::size_t&
  option_length () const;

  std::size_t&
  option_length ();

  void
  option_length (const std::size_t&);

  bool
  option_length_specified () const;

  void
  option_length_specified (bool);

  const bool&
  ascii_tree () const;

  bool&
  ascii_tree ();

  void
  ascii_tree (const bool&);

  const bool&
  ansi_color () const;

  bool&
  ansi_color ();

  void
  ansi_color (const bool&);

  const bool&
  exclude_base () const;

  bool&
  exclude_base ();

  void
  exclude_base (const bool&);

  const bool&
  include_base_last () const;

  bool&
  include_base_last ();

  void
  include_base_last (const bool&);

  const std::map<std::string, std::string>&
  class_doc () const;

  std::map<std::string, std::string>&
  class_doc ();

  void
  class_doc (const std::map<std::string, std::string>&);

  bool
  class_doc_specified () const;

  void
  class_doc_specified (bool);

  const std::vector<std::string>&
  class_ () const;

  std::vector<std::string>&
  class_ ();

  void
  class_ (const std::vector<std::string>&);

  bool
  class__specified () const;

  void
  class__specified (bool);

  const std::map<std::string, std::string>&
  docvar () const;

  std::map<std::string, std::string>&
  docvar ();

  void
  docvar (const std::map<std::string, std::string>&);

  bool
  docvar_specified () const;

  void
  docvar_specified (bool);

  const std::vector<std::string>&
  link_regex () const;

  std::vector<std::string>&
  link_regex ();

  void
  link_regex (const std::vector<std::string>&);

  bool
  link_regex_specified () const;

  void
  link_regex_specified (bool);

  const bool&
  link_regex_trace () const;

  bool&
  link_regex_trace ();

  void
  link_regex_trace (const bool&);

  const std::map<char, std::string>&
  html_heading_map () const;

  std::map<char, std::string>&
  html_heading_map ();

  void
  html_heading_map (const std::map<char, std::string>&);

  bool
  html_heading_map_specified () const;

  void
  html_heading_map_specified (bool);

  const bool&
  omit_link_check () const;

  bool&
  omit_link_check ();

  void
  omit_link_check (const bool&);

  const std::vector<std::string>&
  hxx_prologue () const;

  std::vector<std::string>&
  hxx_prologue ();

  void
  hxx_prologue (const std::vector<std::string>&);

  bool
  hxx_prologue_specified () const;

  void
  hxx_prologue_specified (bool);

  const std::vector<std::string>&
  ixx_prologue () const;

  std::vector<std::string>&
  ixx_prologue ();

  void
  ixx_prologue (const std::vector<std::string>&);

  bool
  ixx_prologue_specified () const;

  void
  ixx_prologue_specified (bool);

  const std::vector<std::string>&
  cxx_prologue () const;

  std::vector<std::string>&
  cxx_prologue ();

  void
  cxx_prologue (const std::vector<std::string>&);

  bool
  cxx_prologue_specified () const;

  void
  cxx_prologue_specified (bool);

  const std::vector<std::string>&
  man_prologue () const;

  std::vector<std::string>&
  man_prologue ();

  void
  man_prologue (const std::vector<std::string>&);

  bool
  man_prologue_specified () const;

  void
  man_prologue_specified (bool);

  const std::vector<std::string>&
  html_prologue () const;

  std::vector<std::string>&
  html_prologue ();

  void
  html_prologue (const std::vector<std::string>&);

  bool
  html_prologue_specified () const;

  void
  html_prologue_specified (bool);

  const std::vector<std::string>&
  txt_prologue () const;

  std::vector<std::string>&
  txt_prologue ();

  void
  txt_prologue (const std::vector<std::string>&);

  bool
  txt_prologue_specified () const;

  void
  txt_prologue_specified (bool);

  const std::vector<std::string>&
  hxx_epilogue () const;

  std::vector<std::string>&
  hxx_epilogue ();

  void
  hxx_epilogue (const std::vector<std::string>&);

  bool
  hxx_epilogue_specified () const;

  void
  hxx_epilogue_specified (bool);

  const std::vector<std::string>&
  ixx_epilogue () const;

  std::vector<std::string>&
  ixx_epilogue ();

  void
  ixx_epilogue (const std::vector<std::string>&);

  bool
  ixx_epilogue_specified () const;

  void
  ixx_epilogue_specified (bool);

  const std::vector<std::string>&
  cxx_epilogue () const;

  std::vector<std::string>&
  cxx_epilogue ();

  void
  cxx_epilogue (const std::vector<std::string>&);

  bool
  cxx_epilogue_specified () const;

  void
  cxx_epilogue_specified (bool);

  const std::vector<std::string>&
  man_epilogue () const;

  std::vector<std::string>&
  man_epilogue ();

  void
  man_epilogue (const std::vector<std::string>&);

  bool
  man_epilogue_specified () const;

  void
  man_epilogue_specified (bool);

  const std::vector<std::string>&
  html_epilogue () const;

  std::vector<std::string>&
  html_epilogue ();

  void
  html_epilogue (const std::vector<std::string>&);

  bool
  html_epilogue_specified () const;

  void
  html_epilogue_specified (bool);

  const std::vector<std::string>&
  txt_epilogue () const;

  std::vector<std::string>&
  txt_epilogue ();

  void
  txt_epilogue (const std::vector<std::string>&);

  bool
  txt_epilogue_specified () const;

  void
  txt_epilogue_specified (bool);

  const std::string&
  hxx_prologue_file () const;

  std::string&
  hxx_prologue_file ();

  void
  hxx_prologue_file (const std::string&);

  bool
  hxx_prologue_file_specified () const;

  void
  hxx_prologue_file_specified (bool);

  const std::string&
  ixx_prologue_file () const;

  std::string&
  ixx_prologue_file ();

  void
  ixx_prologue_file (const std::string&);

  bool
  ixx_prologue_file_specified () const;

  void
  ixx_prologue_file_specified (bool);

  const std::string&
  cxx_prologue_file () const;

  std::string&
  cxx_prologue_file ();

  void
  cxx_prologue_file (const std::string&);

  bool
  cxx_prologue_file_specified () const;

  void
  cxx_prologue_file_specified (bool);

  const std::string&
  man_prologue_file () const;

  std::string&
  man_prologue_file ();

  void
  man_prologue_file (const std::string&);

  bool
  man_prologue_file_specified () const;

  void
  man_prologue_file_specified (bool);

  const std::string&
  html_prologue_file () const;

  std::string&
  html_prologue_file ();

  void
  html_prologue_file (const std::string&);

  bool
  html_prologue_file_specified () const;

  void
  html_prologue_file_specified (bool);

  const std::string&
  txt_prologue_file () const;

  std::string&
  txt_prologue_file ();

  void
  txt_prologue_file (const std::string&);

  bool
  txt_prologue_file_specified () const;

  void
  txt_prologue_file_specified (bool);

  const std::string&
  hxx_epilogue_file () const;

  std::string&
  hxx_epilogue_file ();

  void
  hxx_epilogue_file (const std::string&);

  bool
  hxx_epilogue_file_specified () const;

  void
  hxx_epilogue_file_specified (bool);

  const std::string&
  ixx_epilogue_file () const;

  std::string&
  ixx_epilogue_file ();

  void
  ixx_epilogue_file (const std::string&);

  bool
  ixx_epilogue_file_specified () const;

  void
  ixx_epilogue_file_specified (bool);

  const std::string&
  cxx_epilogue_file () const;

  std::string&
  cxx_epilogue_file ();

  void
  cxx_epilogue_file (const std::string&);

  bool
  cxx_epilogue_file_specified () const;

  void
  cxx_epilogue_file_specified (bool);

  const std::string&
  man_epilogue_file () const;

  std::string&
  man_epilogue_file ();

  void
  man_epilogue_file (const std::string&);

  bool
  man_epilogue_file_specified () const;

  void
  man_epilogue_file_specified (bool);

  const std::string&
  html_epilogue_file () const;

  std::string&
  html_epilogue_file ();

  void
  html_epilogue_file (const std::string&);

  bool
  html_epilogue_file_specified () const;

  void
  html_epilogue_file_specified (bool);

  const std::string&
  txt_epilogue_file () const;

  std::string&
  txt_epilogue_file ();

  void
  txt_epilogue_file (const std::string&);

  bool
  txt_epilogue_file_specified () const;

  void
  txt_epilogue_file_specified (bool);

  const std::string&
  output_prefix () const;

  std::string&
  output_prefix ();

  void
  output_prefix (const std::string&);

  bool
  output_prefix_specified () const;

  void
  output_prefix_specified (bool);

  const std::string&
  output_suffix () const;

  std::string&
  output_suffix ();

  void
  output_suffix (const std::string&);

  bool
  output_suffix_specified () const;

  void
  output_suffix_specified (bool);

  const std::string&
  hxx_suffix () const;

  std::string&
  hxx_suffix ();

  void
  hxx_suffix (const std::string&);

  bool
  hxx_suffix_specified () const;

  void
  hxx_suffix_specified (bool);

  const std::string&
  ixx_suffix () const;

  std::string&
  ixx_suffix ();

  void
  ixx_suffix (const std::string&);

  bool
  ixx_suffix_specified () const;

  void
  ixx_suffix_specified (bool);

  const std::string&
  cxx_suffix () const;

  std::string&
  cxx_suffix ();

  void
  cxx_suffix (const std::string&);

  bool
  cxx_suffix_specified () const;

  void
  cxx_suffix_specified (bool);

  const std::string&
  man_suffix () const;

  std::string&
  man_suffix ();

  void
  man_suffix (const std::string&);

  bool
  man_suffix_specified () const;

  void
  man_suffix_specified (bool);

  const std::string&
  html_suffix () const;

  std::string&
  html_suffix ();

  void
  html_suffix (const std::string&);

  bool
  html_suffix_specified () const;

  void
  html_suffix_specified (bool);

  const std::string&
  txt_suffix () const;

  std::string&
  txt_suffix ();

  void
  txt_suffix (const std::string&);

  bool
  txt_suffix_specified () const;

  void
  txt_suffix_specified (bool);

  const std::string&
  dep_suffix () const;

  std::string&
  dep_suffix ();

  void
  dep_suffix (const std::string&);

  bool
  dep_suffix_specified () const;

  void
  dep_suffix_specified (bool);

  const std::string&
  dep_file () const;

  std::string&
  dep_file ();

  void
  dep_file (const std::string&);

  bool
  dep_file_specified () const;

  void
  dep_file_specified (bool);

  const std::string&
  option_prefix () const;

  std::string&
  option_prefix ();

  void
  option_prefix (const std::string&);

  bool
  option_prefix_specified () const;

  void
  option_prefix_specified (bool);

  const std::string&
  option_separator () const;

  std::string&
  option_separator ();

  void
  option_separator (const std::string&);

  bool
  option_separator_specified () const;

  void
  option_separator_specified (bool);

  const bool&
  keep_separator () const;

  bool&
  keep_separator ();

  void
  keep_separator (const bool&);

  const bool&
  no_combined_flags () const;

  bool&
  no_combined_flags ();

  void
  no_combined_flags (const bool&);

  const bool&
  no_combined_values () const;

  bool&
  no_combined_values ();

  void
  no_combined_values (const bool&);

  const bool&
  include_with_brackets () const;

  bool&
  include_with_brackets ();

  void
  include_with_brackets (const bool&);

  const std::string&
  include_prefix () const;

  std::string&
  include_prefix ();

  void
  include_prefix (const std::string&);

  bool
  include_prefix_specified () const;

  void
  include_prefix_specified (bool);

  const std::string&
  guard_prefix () const;

  std::string&
  guard_prefix ();

  void
  guard_prefix (const std::string&);

  bool
  guard_prefix_specified () const;

  void
  guard_prefix_specified (bool);

  const std::map<std::string, std::string>&
  reserved_name () const;

  std::map<std::string, std::string>&
  reserved_name ();

  void
  reserved_name (const std::map<std::string, std::string>&);

  bool
  reserved_name_specified () const;

  void
  reserved_name_specified (bool);

  const std::string&
  options_file () const;

  std::string&
  options_file ();

  void
  options_file (const std::string&);

  bool
  options_file_specified () const;

  void
  options_file_specified (bool);

  // Print usage information.
  //
  static ::cli::usage_para
  print_usage (::std::ostream&,
               ::cli::usage_para = ::cli::usage_para::none);

  // Implementation details.
  //
  protected:
  bool
  _parse (const char*, ::cli::scanner&);

  private:
  bool
  _parse (::cli::scanner&,
          ::cli::unknown_mode option,
          ::cli::unknown_mode argument);

  public:
  std::uint64_t build2_metadata_;
  bool build2_metadata_specified_;
  bool help_;
  bool version_;
  std::vector<std::string> include_path_;
  bool include_path_specified_;
  std::string output_dir_;
  bool output_dir_specified_;
  cxx_version std_;
  bool std_specified_;
  bool generate_modifier_;
  bool generate_specifier_;
  bool generate_parse_;
  bool generate_merge_;
  bool generate_description_;
  bool generate_file_scanner_;
  bool generate_vector_scanner_;
  bool generate_group_scanner_;
  bool suppress_inline_;
  bool suppress_cli_;
  std::string cli_namespace_;
  bool cli_namespace_specified_;
  std::string ostream_type_;
  bool ostream_type_specified_;
  std::string export_symbol_;
  bool export_symbol_specified_;
  bool generate_cxx_;
  bool generate_man_;
  bool generate_html_;
  bool generate_txt_;
  bool generate_dep_;
  bool stdout__;
  bool suppress_undocumented_;
  bool suppress_usage_;
  bool long_usage_;
  bool short_usage_;
  std::string page_usage_;
  bool page_usage_specified_;
  std::size_t option_length_;
  bool option_length_specified_;
  bool ascii_tree_;
  bool ansi_color_;
  bool exclude_base_;
  bool include_base_last_;
  std::map<std::string, std::string> class_doc_;
  bool class_doc_specified_;
  std::vector<std::string> class__;
  bool class__specified_;
  std::map<std::string, std::string> docvar_;
  bool docvar_specified_;
  std::vector<std::string> link_regex_;
  bool link_regex_specified_;
  bool link_regex_trace_;
  std::map<char, std::string> html_heading_map_;
  bool html_heading_map_specified_;
  bool omit_link_check_;
  std::vector<std::string> hxx_prologue_;
  bool hxx_prologue_specified_;
  std::vector<std::string> ixx_prologue_;
  bool ixx_prologue_specified_;
  std::vector<std::string> cxx_prologue_;
  bool cxx_prologue_specified_;
  std::vector<std::string> man_prologue_;
  bool man_prologue_specified_;
  std::vector<std::string> html_prologue_;
  bool html_prologue_specified_;
  std::vector<std::string> txt_prologue_;
  bool txt_prologue_specified_;
  std::vector<std::string> hxx_epilogue_;
  bool hxx_epilogue_specified_;
  std::vector<std::string> ixx_epilogue_;
  bool ixx_epilogue_specified_;
  std::vector<std::string> cxx_epilogue_;
  bool cxx_epilogue_specified_;
  std::vector<std::string> man_epilogue_;
  bool man_epilogue_specified_;
  std::vector<std::string> html_epilogue_;
  bool html_epilogue_specified_;
  std::vector<std::string> txt_epilogue_;
  bool txt_epilogue_specified_;
  std::string hxx_prologue_file_;
  bool hxx_prologue_file_specified_;
  std::string ixx_prologue_file_;
  bool ixx_prologue_file_specified_;
  std::string cxx_prologue_file_;
  bool cxx_prologue_file_specified_;
  std::string man_prologue_file_;
  bool man_prologue_file_specified_;
  std::string html_prologue_file_;
  bool html_prologue_file_specified_;
  std::string txt_prologue_file_;
  bool txt_prologue_file_specified_;
  std::string hxx_epilogue_file_;
  bool hxx_epilogue_file_specified_;
  std::string ixx_epilogue_file_;
  bool ixx_epilogue_file_specified_;
  std::string cxx_epilogue_file_;
  bool cxx_epilogue_file_specified_;
  std::string man_epilogue_file_;
  bool man_epilogue_file_specified_;
  std::string html_epilogue_file_;
  bool html_epilogue_file_specified_;
  std::string txt_epilogue_file_;
  bool txt_epilogue_file_specified_;
  std::string output_prefix_;
  bool output_prefix_specified_;
  std::string output_suffix_;
  bool output_suffix_specified_;
  std::string hxx_suffix_;
  bool hxx_suffix_specified_;
  std::string ixx_suffix_;
  bool ixx_suffix_specified_;
  std::string cxx_suffix_;
  bool cxx_suffix_specified_;
  std::string man_suffix_;
  bool man_suffix_specified_;
  std::string html_suffix_;
  bool html_suffix_specified_;
  std::string txt_suffix_;
  bool txt_suffix_specified_;
  std::string dep_suffix_;
  bool dep_suffix_specified_;
  std::string dep_file_;
  bool dep_file_specified_;
  std::string option_prefix_;
  bool option_prefix_specified_;
  std::string option_separator_;
  bool option_separator_specified_;
  bool keep_separator_;
  bool no_combined_flags_;
  bool no_combined_values_;
  bool include_with_brackets_;
  std::string include_prefix_;
  bool include_prefix_specified_;
  std::string guard_prefix_;
  bool guard_prefix_specified_;
  std::map<std::string, std::string> reserved_name_;
  bool reserved_name_specified_;
  std::string options_file_;
  bool options_file_specified_;
};

#include "options.ixx"

// Begin epilogue.
//
//
// End epilogue.

#endif // CLI_OPTIONS_HXX
